% Generated by GrindEQ Word-to-LaTeX 
\documentclass{article} % use \documentstyle for old LaTeX compilers
\usepackage{ctex}
\usepackage[utf8]{inputenc} % 'cp1252'-Western, 'cp1251'-Cyrillic, etc.
\usepackage[english]{babel} % 'french', 'german', 'spanish', 'danish', etc.
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{txfonts}
\usepackage{mathdots}
\usepackage[classicReIm]{kpfonts}
\usepackage{graphicx}

% You can include more LaTeX packages here 


\begin{document}

%\selectlanguage{english} % remove comment delimiter ('%') and select language if required


\noindent

\noindent

\noindent

\noindent

\noindent \textbf{Lab2：三位十进制计数器}

\noindent \textbf{\textit{高政 11912015}}

\begin{enumerate}
    \item \textbf{\textit{ }}简述

          \begin{enumerate}
              \item  实验目的
          \end{enumerate}
\end{enumerate}

本次实验通过设计VHDL代码实验三位十进制计数器来学习VHDL语言中的条件并发语句和if嵌套语句。

\begin{enumerate}
    \item \begin{enumerate}
              \item  十进制计数器
          \end{enumerate}
\end{enumerate}

在十进制计数体制中，每位数都可能是0，1，2，{\dots}，9十个数码中的任意一个，且``逢十进一``。根据计数器的构成原理，必须由四个触发器的状态来表示一位十进制数的四位二进制编码。本次实验使用8421BCD码的编码方式来表示一位十进制数。

\includegraphics*[width=4.02in, height=1.19in]{image1}通过D触发器实现的三位十进制计数器逻辑狂徒如下：

\begin{enumerate}
    \item  实验准备
\end{enumerate}

\noindent \includegraphics*[width=3.45in, height=3.33in]{image2}通过D触发器实现的三位十进制计数器电路图如下：

\begin{enumerate}
    \item  VHDL代码与test bench代码
\end{enumerate}

实验中使用条件并发语句实现三位十进制计数器：

\noindent library IEEE;

\noindent use ieee.std\_logic\_1164.all;

\noindent use ieee.std\_logic\_arith.all;

\noindent use ieee.std\_logic\_unsigned.all;

\noindent

\noindent entity three\_digit\_decimal\_counter is

\noindent     Port ( CLK : in STD\_LOGIC;

\noindent            RESET : in STD\_LOGIC;

\noindent            d1 : out STD\_LOGIC\_VECTOR (3 downto 0);

\noindent            d10 : out STD\_LOGIC\_VECTOR (3 downto 0);

\noindent            d100 : out STD\_LOGIC\_VECTOR (3 downto 0));

\noindent end three\_digit\_decimal\_counter;

\noindent

\noindent architecture Behavioral of three\_digit\_decimal\_counter is

\noindent signal d1\_reg, d10\_reg, d100\_reg: std\_logic\_vector (3 downto 0);

\noindent signal d1\_next, d10\_next, d100\_next: std\_logic\_vector (3 downto 0);

\noindent

\noindent begin

\noindent -- register

\noindent process (CLK, RESET) is

\noindent begin

\noindent     if RESET = '1' then

\noindent         d1\_reg $\mathrm{<}$="0000";

\noindent         d10\_reg $\mathrm{<}$="0000";

\noindent         d100\_reg $\mathrm{<}$="0000";

\noindent     elsif CLK'event and CLK='1' then

\noindent         d1\_reg $\mathrm{<}$= d1\_next;

\noindent         d10\_reg $\mathrm{<}$= d10\_next;

\noindent         d100\_reg $\mathrm{<}$= d100\_next;

\noindent     end if;

\noindent end process;

\noindent -- next-state logic

\noindent d1\_next $\mathrm{<}$= "0000" when d1\_reg = 9 else d1\_reg+1;

\noindent d10\_next $\mathrm{<}$= "0000" when (d1\_reg = 9 and d10\_reg = 9) else

\noindent             d10\_reg+1 when d1\_reg = 9 else d10\_reg;

\noindent d100\_next $\mathrm{<}$= "0000" when (d1\_reg=9 and d10\_reg=9 and d100\_reg=9) else

\noindent              d100\_reg+1 when (d1\_reg=9 and d10\_reg=9) else d100\_reg;

\noindent -- Output logic

\noindent d1 $\mathrm{<}$= d1\_reg; d10 $\mathrm{<}$= d10\_reg; d100 $\mathrm{<}$= d100\_reg;

\noindent end Behavioral;

test bench文件如下：

\noindent library IEEE;

\noindent use ieee.std\_logic\_1164.all;

\noindent USE ieee.numeric\_std.ALL;

\noindent use ieee.std\_logic\_unsigned.all;

\noindent

\noindent entity tb\_three\_digit\_decimal\_counter is

\noindent end tb\_three\_digit\_decimal\_counter;

\noindent

\noindent architecture Behavioral of tb\_three\_digit\_decimal\_counter is

\noindent     component three\_digit\_decimal\_counter

\noindent     Port ( CLK : in STD\_LOGIC;

\noindent            RESET : in STD\_LOGIC;

\noindent            d1 : out STD\_LOGIC\_VECTOR (3 downto 0);

\noindent            d10 : out STD\_LOGIC\_VECTOR (3 downto 0);

\noindent            d100 : out STD\_LOGIC\_VECTOR (3 downto 0));

\noindent     end component;

\noindent     --Inputs

\noindent     signal CLK : std\_logic := '0';

\noindent     signal RESET : std\_logic := '0';

\noindent

\noindent     --Outputs

\noindent     signal d1 : std\_logic\_vector(3 downto 0):="0000";

\noindent     signal d10 : std\_logic\_vector(3 downto 0):="0000";

\noindent     signal d100 : std\_logic\_vector(3 downto 0):="0000";

\noindent

\noindent begin

\noindent     -- Instantiate the Unit Under Test (UUT)

\noindent     uut: three\_digit\_decimal\_counter PORT MAP (

\noindent         CLK =$\mathrm{>}$ CLK,

\noindent         RESET =$\mathrm{>}$ RESET,

\noindent         d1 =$\mathrm{>}$ d1,

\noindent         d10 =$\mathrm{>}$ d10,

\noindent         d100 =$\mathrm{>}$ d100

\noindent     );

\noindent

\noindent     clock\_gen: process

\noindent     constant period : time := 100 ns;

\noindent     begin

\noindent         CLK $\mathrm{<}$= '0';

\noindent         wait for period/2;

\noindent         CLK $\mathrm{<}$= '1';

\noindent         wait for period/2;

\noindent     end process;

\noindent

\noindent     reset\_process : process

\noindent     begin

\noindent         RESET $\mathrm{<}$= '1';

\noindent         for i in 1 to 2 loop

\noindent             wait until CLK = '1';

\noindent         end loop;

\noindent         RESET $\mathrm{<}$= '0';

\noindent         wait;

\noindent     end process;

\noindent

\noindent     monitor : process

\noindent     constant n : integer := 1000;

\noindent     variable number : integer range 0 to 999 :=0;

\noindent     begin

\noindent         wait until reset $\mathrm{<}$= '0';

\noindent         wait for 1 ns;

\noindent         for i in 0 to n loop

number:=to\_integer(unsigned(d100))*100+to\_integer(unsigned(d10))*10+

to\_integer(unsigned(d1));

\noindent             assert number = i mod n

\noindent             report "count of " \& integer'image(i mod n) \& " failed"

\noindent             severity error;

\noindent             wait until clk = '1';

\noindent             wait for 1 ns;

\noindent         end loop;

\noindent         wait;

\noindent     end process;

\noindent end Behavioral;

\begin{enumerate}
    \item  实验结果与分析

          \begin{enumerate}
              \item  \includegraphics*[width=5.40in, height=2.27in]{image3}行为仿真
          \end{enumerate}
\end{enumerate}

\noindent 行为仿真结果如图，代码完整实现三位十进制计数器的功能。

\begin{enumerate}
    \item \begin{enumerate}
              \item  \includegraphics*[width=5.00in, height=1.94in]{image4}综合仿真
          \end{enumerate}
\end{enumerate}



综合仿真结果如上。\includegraphics*[width=5.78in, height=1.01in]{image5}\includegraphics*[width=4.15in, height=2.04in]{image6}

\begin{enumerate}
    \item \begin{enumerate}
              \item  \includegraphics*[width=5.72in, height=1.02in]{image7}\includegraphics*[width=4.61in, height=2.10in]{image8}\includegraphics*[width=4.67in, height=2.11in]{image9}时序仿真
          \end{enumerate}
\end{enumerate}

时序仿真结果及原理图如上。

\begin{enumerate}
    \item \begin{enumerate}
              \item  RTL分析
          \end{enumerate}
\end{enumerate}

\includegraphics*[width=5.77in, height=2.77in]{image10}RTL原理图如下，可以发现，根据代码生成的电路原理图与实验前绘制的电路原理图基本一致。

\begin{enumerate}
    \item  实验结论
\end{enumerate}

通过本次实验我学习了VHDL语言中的条件并发语句使用，并成功实现了三位十进制计数器的仿真。实验过程中遇到了诸如\includegraphics*[width=2.08in, height=0.15in]{image11}等问题，再浏览相关文章后均找到了解决方案。但由于未知原因，我的FPGA板暂不能连接到仿真器，故无法继续验证在实际情况下程序的时序等项目，目前我让在努力尝试解决FPGA板与仿真器的连接问题。


\end{document}

